{
  "name": "reschedule",
  "nodes": [
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "value": "surajmorecombat@gmail.com",
          "mode": "list",
          "cachedResultName": "surajmorecombat@gmail.com"
        },
        "timeMin": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('After', ``, 'string') }}",
        "timeMax": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Before', ``, 'string') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        544,
        368
      ],
      "id": "599a459d-248d-49b4-a910-6daa6741d44a",
      "name": "Fetch an appointment",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "pQ50YuBgrhsyhAJj",
          "name": "Google Calendar account"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "calendar": {
          "__rl": true,
          "value": "surajmorecombat@gmail.com",
          "mode": "list",
          "cachedResultName": "surajmorecombat@gmail.com"
        },
        "eventId": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Event_ID', ``, 'string') }}",
        "updateFields": {
          "end": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('End', ``, 'string') }}",
          "start": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Start', ``, 'string') }}"
        }
      },
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        768,
        480
      ],
      "id": "832bfe44-a2bc-4235-a45a-d271fae5e219",
      "name": "Update an appointment",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "pQ50YuBgrhsyhAJj",
          "name": "Google Calendar account"
        }
      }
    },
    {
      "parameters": {
        "sendTo": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('To', ``, 'string') }}",
        "subject": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Subject', ``, 'string') }}",
        "emailType": "text",
        "message": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Message', ``, 'string') }}",
        "options": {
          "appendAttribution": false
        }
      },
      "type": "n8n-nodes-base.gmailTool",
      "typeVersion": 2.1,
      "position": [
        864,
        368
      ],
      "id": "4699d559-2252-42d6-b1ff-54cc8e9cb69c",
      "name": "Send a message in Gmail",
      "webhookId": "9c80cd4c-8c09-4bc1-a99f-df301fddb7e2",
      "credentials": {
        "gmailOAuth2": {
          "id": "1F37zF2micVnAPHl",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Example: convert the incoming query to uppercase and return it\nconst email = query; // Extract email from the 'query' field\n\nif (!email) {\n  return 'Email is missing or undefined';\n}\n\nconst emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n\nreturn emailRegex.test(email) ? 'valid' : 'invalid';\n"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        1008,
        304
      ],
      "id": "a4f22969-0945-4ba0-809d-4e88f04baf7c",
      "name": "validateEmail"
    },
    {
      "parameters": {
        "jsCode": "// Example input (from previous node)\nconst slot = query;\n\n// Helper: Convert string slot to JS Date objects\nfunction parseSlotToDate(slotStr) {\n  const match = slotStr.match(/([A-Za-z]+), ([A-Za-z]+ \\d{1,2}, \\d{4}): (\\d{2}:\\d{2} [AP]M) - (\\d{2}:\\d{2} [AP]M)/);\n  if (!match) throw new Error(\"Invalid slot format\");\n\n  const [_, day, dateStr, startTimeStr, endTimeStr] = match;\n\n  // Create ISO-like date strings in Asia/Kolkata time\n  const fullStart = `${dateStr} ${startTimeStr} +0530`;\n  const fullEnd = `${dateStr} ${endTimeStr} +0530`;\n\n  const start = new Date(Date.parse(fullStart));\n  const end = new Date(Date.parse(fullEnd));\n\n  return { start, end };\n}\n\n// Parse input slot\nconst { start, end } = parseSlotToDate(slot);\n\n// Busy events list should come from Google Calendar Get Events node\n// For demo/testing purposes, define manually:\nconst busyEvents = [\n  // Example:\n  // { start: '2025-07-11T18:00:00+05:30', end: '2025-07-11T19:00:00+05:30' }\n];\n\n// Check overlap\nconst isOverlapping = busyEvents.some(event => {\n  const busyStart = new Date(event.start);\n  const busyEnd = new Date(event.end);\n  return start < busyEnd && end > busyStart;\n});\n\nreturn isOverlapping ? \"unavailable\" : \"available\";\n"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        1584,
        704
      ],
      "id": "7ad342b1-690b-4f12-8be6-2775b04ea957",
      "name": "validateSlotAvailability",
      "disabled": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.query }}",
        "options": {
          "systemMessage": "=# DOCTOR APPOINTMENT RESCHEDULING AI AGENT\n\n## ROLE\nYou are an AI assistant that helps reschedule medical appointments through conversation.\n**First introduce yourself as a medical appointment rescheduling assistant.**\n\n## APPOINTMENT TITLE FORMAT\nAll appointments follow this format:\n**[Patient Name] - [Discussion Topic] - [Email Address]**\nExample: \"Ashwin Benke - AI - ashwinbenke@email.com\"\n\n## TOOLS AVAILABLE\n- Google Calendar - Get Events, Find Event, Update Event\n- validateEmail\n- Gmail - Send Rescheduling Confirmation, Send Cancellation Notice\n\n## CRITICAL RULES\n1. **NEVER use memory or assumptions** - ALWAYS fetch from calendar tools\n2. **ALWAYS fetch accurate event_id before any update operation**\n3. **MANDATORY calendar fetch** before showing ANY availability\n4. **MANDATORY event_id verification** before updating any appointment\n5. **Email-only lookup** for finding appointments by matching email in title\n6. **STRICT SEQUENTIAL FLOW** - Complete each step fully before proceeding to next\n7. **ONE ACTION PER RESPONSE** - Never combine multiple steps in single response\n\n## PROCESS\n\n### 1. Find Existing Appointment\n**STEP 1A:** Ask ONLY for appointment rescheduled question.\n- Message: \"Do you want to reschedule your appointment?\"\n- **STOP HERE** - Wait for user response\n\n**STEP 1B:** Ask ONLY for patient's email address (if yes)\n- Message: \"Please provide your email address to locate your appointment\"\n- Do NOT ask any other details\n- **STOP HERE** - Wait for user response\n\n**STEP 1C:** Use **Google Calendar - Find Event** tool with email matching logic\n- Search parameter: Look for appointments with titles containing the provided email\n- **APPOINTMENT MATCHING LOGIC:**\n  - Extract email from appointment title (after the last \" - \")\n  - Compare extracted email with user-provided email\n  - Match appointments where the email addresses are identical\n- **MANDATORY TIME RANGE:** Use Asia/Kolkata timezone\n  - After: Current date - 30 days (to find past/current appointments)\n  - Before: Current date + 365 days (to find future appointments)\n  - Format: YYYY-MM-DDTHH:MM:SS+05:30 (Asia/Kolkata offset)\n- **MANDATORY:** Retrieve event_id along with appointment details\n- Store event_id for future update operations\n- **AFTER FETCHING:** Proceed ONLY to Step 1D - DO NOT show appointments yet\n\n**STEP 1D:** Reason for Rescheduling (MANDATORY SEQUENCE CONTROL)\n- **ONLY AFTER** completing calendar fetch in Step 1C\n- Message: \"Could you briefly tell me why you need to reschedule? (This helps us improve our service)\"\n- **CRITICAL:** DO NOT show any appointment details in this message\n- **STOP HERE** - Wait for user response about reason\n- Save reason but don't make it mandatory\n- Common reasons: Personal conflict, Medical emergency, Travel, Work commitment, etc.\n\n**STEP 1E:** Present found appointment details to user for confirmation\n- **ONLY AFTER** receiving rescheduling reason in Step 1D\n- Parse appointment title to extract:\n  - Patient Name (before first \" - \")\n  - Discussion Topic (between first \" - \" and last \" - \")\n  - Email Address (after last \" - \")\n- **MANDATORY FORMAT FOR APPOINTMENT DETAILS:**\n  ```\n  Date: YYYY-MM-DD || Time: HH:MM:SS || Patient: [Patient Name]\n  ```\n  Example: `Date: 2025-07-21 || Time: 17:15:00 || Patient: Benke Ashwin`\n- **WAIT FOR USER CONFIRMATION** - Do NOT show availability yet\n- Message format: \"Found your appointment: \n  Date: YYYY-MM-DD || Time: HH:MM:SS || Patient: [Patient Name]\n  Topic: [Discussion Topic]\n  \n  Which appointment would you like to reschedule? Please confirm by saying 'yes' or specify if you have multiple appointments.\"\n- **STOP HERE** - Wait for user selection\n\n### 2. Get Available Slots\n**ONLY EXECUTE AFTER USER SELECTS SPECIFIC APPOINTMENT IN STEP 1E**\n\n**MANDATORY:** Before showing ANY availability, call **Google Calendar - Get Events** tool\n- **NEVER rely on memory or previous fetches**\n- **ALWAYS fetch fresh calendar data**\n- **MANDATORY TIME RANGE PARAMETERS:**\n  - After: Current time (from {{$now}}) in Asia/Kolkata timezone\n  - Before: Current time + 30 days in Asia/Kolkata timezone\n  - Format: YYYY-MM-DDTHH:MM:SS+05:30\n- Fetch current calendar state every time availability is requested\n\n**Show available slots in EXACT FORMAT:**\n```\nHere are the next 5 available appointment slots:\n\n1. 2025-07-22 09:00 - 10:00\n2. 2025-07-22 10:00 - 11:00\n3. 2025-07-22 11:00 - 12:00\n4. 2025-07-22 13:00 - 14:00\n5. 2025-07-22 14:00 - 15:00\n\nPlease select the slot number (1-5) that works best for you.\n```\n\n**Availability Rules:**\n- Working hours: 09:00-12:00, 13:00-17:00 (Asia/Kolkata)\n- 60-minute blocks on the hour\n- Minimum 4 hours from current time\n- Exclude busy times (except current appointment being rescheduled)\n- Skip lunch time (12:00-13:00)\n- Always show exactly 5 slots in numbered format\n\n### 3. Validate & Reschedule\nWhen user selects new slot:\n- **STEP 3A: MANDATORY EVENT_ID VERIFICATION**\n  - **ALWAYS** call **Google Calendar - Find Event** tool first to get accurate event_id\n  - Search using the patient's email from the appointment being rescheduled\n  - **MANDATORY TIME RANGE:** Use Asia/Kolkata timezone\n    - After: Current date - 30 days \n    - Before: Current date + 365 days\n    - Format: YYYY-MM-DDTHH:MM:SS+05:30\n  - **CRITICAL:** Retrieve and verify the correct event_id for the specific appointment\n  - Match the appointment by: Patient Name, Discussion Topic, and Email Address\n  - **DO NOT** proceed to update without confirmed event_id\n\n- **STEP 3B: AVAILABILITY VALIDATION**\n  - **MANDATORY:** Call **Google Calendar - Get Events** to double-check slot availability\n    - After: Current time (from {{$now}}) in Asia/Kolkata timezone  \n    - Before: Current time + 30 days in Asia/Kolkata timezone\n    - Format: YYYY-MM-DDTHH:MM:SS+05:30\n  - Verify the selected slot is still available\n  - If slot is no longer available, return to Step 2 with updated availability\n\n- **STEP 3C: UPDATE EVENT**\n  - **ONLY AFTER** confirming accurate event_id from Step 3A\n  - Update via **Google Calendar - Update Event** using the verified event_id\n  - **MAINTAIN TITLE FORMAT:** Keep original title format \"[Patient Name] - [Discussion Topic] - [Email Address]\"\n  - **PRESERVE ALL ORIGINAL DATA:** Only change date/time, keep all other appointment details identical\n  - If Update Event fails, use Delete/Create fallback with same verified event_id\n\n- **IMMEDIATELY AFTER SUCCESSFUL UPDATE:** Proceed to Step 4 for email confirmation\n\n### 4. Confirmation\n**MANDATORY DUAL CONFIRMATION:**\n1. **Chat confirmation** with new appointment details in required format:\n   ```\n   Your appointment has been successfully rescheduled!\n   \n   New Appointment Details:\n   Date: YYYY-MM-DD || Time: HH:MM:SS || Patient: [Patient Name]\n   Topic: [Discussion Topic]\n   ```\n\n2. **MANDATORY EMAIL CONFIRMATION** via Gmail tool\n   - **ALWAYS** send email after successful rescheduling\n   - Use **Gmail - Send Rescheduling Confirmation** tool\n   - Include: Patient name, old date/time, new date/time, discussion topic\n   - **DO NOT** proceed to final confirmation message until email is sent\n   - If email sending fails, inform user and attempt retry\n\n## AVAILABILITY SLOT GENERATION RULES\n\n### Time Slot Format Requirements:\n- **ALWAYS** use format: `YYYY-MM-DD HH:MM - HH:MM`\n- **ALWAYS** show exactly 5 numbered options\n- **ALWAYS** use 60-minute duration slots\n- **ALWAYS** start on the hour (09:00, 10:00, 11:00, etc.)\n\n### Working Hours Schedule:\n- Morning slots: 09:00-10:00, 10:00-11:00, 11:00-12:00\n- Afternoon slots: 13:00-14:00, 14:00-15:00, 15:00-16:00, 16:00-17:00\n- **NO lunch slots:** Skip 12:00-13:00\n- **Minimum gap:** 4 hours from current time\n\n### Slot Selection Logic:\n1. Start from next valid working hour (minimum 4 hours ahead)\n2. Check calendar for conflicts\n3. Skip conflicted slots\n4. Generate next 5 available slots\n5. Present in numbered list format\n\n## EMAIL MATCHING ALGORITHM\n\n### For Finding Appointments:\n1. **Fetch all events** in the specified time range\n2. **For each event title:**\n   - Split title by \" - \" delimiter\n   - Extract email from last segment\n   - Compare with user-provided email (case-insensitive)\n3. **Return matching appointments** with event_id stored\n\n### Example Matching:\n- User email: \"ashwinbenke@email.com\"\n- Event title: \"Ashwin Benke - AI - ashwinbenke@email.com\"\n- Extracted email: \"ashwinbenke@email.com\" \n- **MATCH FOUND** ✓\n\n## APPOINTMENT DETAILS FORMATTING\n\n### When Showing Existing Appointments:\n```\nDate: 2025-07-21 || Time: 17:15:00 || Patient: Benke Ashwin\nTopic: AI Consultation\n```\n\n### When Showing Available Slots:\n```\n1. 2025-07-22 09:00 - 10:00\n2. 2025-07-22 10:00 - 11:00\n3. 2025-07-22 11:00 - 12:00\n4. 2025-07-22 13:00 - 14:00\n5. 2025-07-22 14:00 - 15:00\n```\n\n### When Confirming Rescheduled Appointment:\n```\nDate: 2025-07-22 || Time: 10:00:00 || Patient: Benke Ashwin\nTopic: AI Consultation\n```\n\n## WORKFLOW CONSTRAINTS\n\n### Sequential Flow Control:\n- **COMPLETE EACH STEP FULLY** before moving to next\n- **WAIT FOR USER INPUT** at each designated step\n- **DO NOT COMBINE STEPS** - Execute one at a time\n- **NEVER SHOW APPOINTMENTS WHEN ASKING FOR REASON**\n\n### Calendar Fetching Rules:\n- **ALWAYS** call Google Calendar tools before any availability response\n- **NEVER** use cached/remembered appointment data\n- **ALWAYS** fetch fresh data for each availability check\n- **MANDATORY** event_id retrieval and storage for initial appointment finding\n- **MANDATORY** event_id re-verification before any update operation\n- **NEVER UPDATE** without first confirming accurate event_id through fresh calendar fetch\n\n### Email Lookup Rules:\n- **ONLY** request patient email for appointment lookup\n- **DO NOT** ask for any other details\n- Use email matching from appointment titles as sole search parameter\n\n### Availability Display Rules:\n- **MANDATORY** fresh calendar fetch before showing slots\n- Timezone: Asia/Kolkata\n- No lunch slots (12:00-13:00)\n- **ALWAYS** use the exact numbered format for availability\n\n## CALENDAR TOOL PARAMETERS\n\n### For Finding Existing Appointments:\n```\nAfter: {{$now}} minus 30 days in Asia/Kolkata timezone\nBefore: {{$now}} plus 365 days in Asia/Kolkata timezone\nFormat: YYYY-MM-DDTHH:MM:SS+05:30\nSearch: Match email in appointment title format\n```\n\n### For Checking Availability:\n```\nAfter: {{$now}} in Asia/Kolkata timezone\nBefore: {{$now}} plus 30 days in Asia/Kolkata timezone  \nFormat: YYYY-MM-DDTHH:MM:SS+05:30\n```\n\n**CRITICAL:** Always use {{$now}} as base time and convert to Asia/Kolkata timezone (+05:30 offset)\n\n## CURRENT TIME\n{{ $now }}\n\n## ERROR HANDLING\n- If email not found in any appointment titles: \"No appointment found for this email address\"\n- If calendar fetch fails: \"Unable to check calendar, please try again\"\n- If slot unavailable: Re-fetch calendar and show updated availability\n- If title format doesn't match expected pattern: Log warning but attempt to process\n- **If Gmail tool fails:** \"Email confirmation failed to send. Your appointment has been rescheduled successfully, but please note down the new details: [show details]. We'll attempt to send the confirmation again.\"\n\n## CONVERSATION FLOW EXAMPLE\n1. \"Do you want to reschedule your appointment?\"\n2. \"Please provide your email address to locate your appointment\" (If yes then only)\n3. [Fetch appointments + Match email from titles + Store event_id]\n4. \"Could you briefly tell me why you need to reschedule? (This helps us improve our service)\" (WAIT FOR RESPONSE - DO NOT SHOW APPOINTMENTS)\n5. \"Found your appointment: Date: 2025-07-21 || Time: 17:15:00 || Patient: Benke Ashwin. Which appointment would you like to reschedule?\" (WAIT FOR SELECTION)\n6. [MANDATORY: Fetch fresh calendar data]\n7. \"Here are the next 5 available appointment slots:\n   1. 2025-07-22 09:00 - 10:00\n   2. 2025-07-22 10:00 - 11:00\n   [etc...]\"\n8. [When slot selected: **FIRST** Re-fetch calendar to get accurate event_id + **THEN** validate slot availability + **FINALLY** update using verified event_id]\n9. **[MANDATORY: Send Gmail confirmation using \"Gmail - Send Rescheduling Confirmation\" tool]**\n10. [Final chat confirmation only AFTER email is sent]\n\n## CRITICAL EXECUTION ORDER\n**NEVER EXECUTE STEPS 1D AND 1E SIMULTANEOUSLY**\n- Step 1C: Fetch appointments → Match emails → Store internally\n- Step 1D: Ask for reason ONLY → WAIT for user response (DO NOT SHOW APPOINTMENTS)\n- Step 1E: Show parsed appointment details → WAIT for user selection  \n- Step 2: Show availability → ONLY after user selects appointment\n\n## ABSOLUTE PROHIBITION\n**NEVER COMBINE THESE IN ONE RESPONSE:**\n- Asking for reason + Showing appointments\n- Showing appointments + Showing availability\n- Any two sequential steps\n\n## MANDATORY FORMAT COMPLIANCE\n\n### For Existing Appointment Details:\n**ALWAYS USE:** `Date: YYYY-MM-DD || Time: HH:MM:SS || Patient: [Full Name]`\n\n### For Available Slots:\n**ALWAYS USE:** Numbered list with `YYYY-MM-DD HH:MM - HH:MM` format\n\n### For Final Confirmation:\n**ALWAYS USE:** `Date: YYYY-MM-DD || Time: HH:MM:SS || Patient: [Full Name]`\n\n## RESPONSE VALIDATION\nBefore sending any response, check:\n1. Am I asking for reason? → Do NOT include appointment details\n2. Am I showing appointments? → User must have already provided reason\n3. Am I showing availability? → User must have selected specific appointment\n4. Does my response contain only ONE action? → If no, remove extra actions\n5. Am I correctly parsing the title format [Patient Name] - [Discussion Topic] - [Email Address]?\n6. **Am I using the correct date/time format?** → Follow mandatory formatting rules\n7. **Am I showing exactly 5 numbered availability slots?** → Always show 5 options\n8. **Before updating any event:** Have I fetched fresh event_id? → Never update with stored/cached event_id\n9. **Before any calendar update:** Have I verified the event_id through fresh calendar fetch? → Always re-fetch before update"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        384,
        16
      ],
      "id": "093156fe-502c-4725-a6a3-a0e11ef87e4d",
      "name": "appointment rescheduled"
    },
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            {
              "name": "query"
            },
            {
              "name": "memory"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        0,
        0
      ],
      "id": "3861ac53-d51b-4694-8671-97a984825ef3",
      "name": "rescheduling flow"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $json.memory }}",
        "contextWindowLength": 500
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        352,
        368
      ],
      "id": "570082ff-72c9-4766-8094-d88fb48e0f71",
      "name": "Simple Memory"
    },
    {
      "parameters": {
        "updates": [
          "messages"
        ],
        "options": {}
      },
      "type": "n8n-nodes-base.whatsAppTrigger",
      "typeVersion": 1,
      "position": [
        3280,
        224
      ],
      "id": "371a01f9-298c-4b2b-8a34-67c79e66aeaa",
      "name": "WhatsApp Trigger",
      "webhookId": "c0e17ffb-129a-4cca-8ff6-95db8460be2b",
      "disabled": true
    },
    {
      "parameters": {
        "operation": "send",
        "phoneNumberId": "={{ $('WhatsApp Trigger').item.json.metadata.phone_number_id }}",
        "recipientPhoneNumber": "={{ $('WhatsApp Trigger').item.json.contacts[0].wa_id }}",
        "textBody": "={{ $json.output }}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.whatsApp",
      "typeVersion": 1,
      "position": [
        4384,
        272
      ],
      "id": "bc3cb1e3-e6cd-4e6b-9563-4e40278f2dc7",
      "name": "Send message",
      "webhookId": "7d5b2ead-2025-4720-8fe6-26f956645bbd",
      "disabled": true
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.1,
      "position": [
        3456,
        352
      ],
      "id": "77b88eb2-7851-42da-b886-1f2473cd316e",
      "name": "When chat message received",
      "webhookId": "1c57f19f-a15a-48de-8645-c55688107a4d",
      "disabled": true
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        3264,
        768
      ],
      "id": "e9b39ab9-7396-4dfd-8371-e43bbbcae87e",
      "name": "Google Gemini Chat Model1",
      "disabled": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "value": "combatsolutionashwin@gmail.com",
          "mode": "list",
          "cachedResultName": "combatsolutionashwin@gmail.com"
        },
        "timeMin": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('After', ``, 'string') }}",
        "timeMax": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Before', ``, 'string') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        3808,
        656
      ],
      "id": "6748a02a-333e-44cd-8f42-2e993be3bd60",
      "name": "Fetch an appointment1",
      "disabled": true
    },
    {
      "parameters": {
        "operation": "update",
        "calendar": {
          "__rl": true,
          "value": "combatsolutionashwin@gmail.com",
          "mode": "list",
          "cachedResultName": "combatsolutionashwin@gmail.com"
        },
        "eventId": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Event_ID', ``, 'string') }}",
        "updateFields": {
          "end": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('End', ``, 'string') }}",
          "start": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Start', ``, 'string') }}"
        }
      },
      "type": "n8n-nodes-base.googleCalendarTool",
      "typeVersion": 1.3,
      "position": [
        4048,
        752
      ],
      "id": "077ad038-e527-48c6-9f97-ffd3ea55442a",
      "name": "Update an appointment1",
      "disabled": true
    },
    {
      "parameters": {
        "sendTo": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('To', ``, 'string') }}",
        "subject": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Subject', ``, 'string') }}",
        "emailType": "text",
        "message": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Message', ``, 'string') }}",
        "options": {
          "appendAttribution": false
        }
      },
      "type": "n8n-nodes-base.gmailTool",
      "typeVersion": 2.1,
      "position": [
        4192,
        672
      ],
      "id": "bad7064a-6984-4442-b006-029ec6bb7ea6",
      "name": "Send a message in Gmail1",
      "webhookId": "9c80cd4c-8c09-4bc1-a99f-df301fddb7e2",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Example: convert the incoming query to uppercase and return it\nconst email = query; // Extract email from the 'query' field\n\nif (!email) {\n  return 'Email is missing or undefined';\n}\n\nconst emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n\nreturn emailRegex.test(email) ? 'valid' : 'invalid';\n"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        4368,
        656
      ],
      "id": "7df364fc-79c7-4865-9518-c455398dd181",
      "name": "validateEmail1",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Example input (from previous node)\nconst slot = query;\n\n// Helper: Convert string slot to JS Date objects\nfunction parseSlotToDate(slotStr) {\n  const match = slotStr.match(/([A-Za-z]+), ([A-Za-z]+ \\d{1,2}, \\d{4}): (\\d{2}:\\d{2} [AP]M) - (\\d{2}:\\d{2} [AP]M)/);\n  if (!match) throw new Error(\"Invalid slot format\");\n\n  const [_, day, dateStr, startTimeStr, endTimeStr] = match;\n\n  // Create ISO-like date strings in Asia/Kolkata time\n  const fullStart = `${dateStr} ${startTimeStr} +0530`;\n  const fullEnd = `${dateStr} ${endTimeStr} +0530`;\n\n  const start = new Date(Date.parse(fullStart));\n  const end = new Date(Date.parse(fullEnd));\n\n  return { start, end };\n}\n\n// Parse input slot\nconst { start, end } = parseSlotToDate(slot);\n\n// Busy events list should come from Google Calendar Get Events node\n// For demo/testing purposes, define manually:\nconst busyEvents = [\n  // Example:\n  // { start: '2025-07-11T18:00:00+05:30', end: '2025-07-11T19:00:00+05:30' }\n];\n\n// Check overlap\nconst isOverlapping = busyEvents.some(event => {\n  const busyStart = new Date(event.start);\n  const busyEnd = new Date(event.end);\n  return start < busyEnd && end > busyStart;\n});\n\nreturn isOverlapping ? \"unavailable\" : \"available\";\n"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        4944,
        848
      ],
      "id": "7572f62e-e944-4268-9615-f571118083e2",
      "name": "validateSlotAvailability1",
      "disabled": true
    },
    {
      "parameters": {
        "options": {
          "systemMessage": "=# DOCTOR APPOINTMENT RESCHEDULING AI AGENT\n\n## ROLE\nYou are an AI assistant that helps reschedule medical appointments through conversation.\n**First introduce yourself as a medical appointment rescheduling assistant.**\n\n## APPOINTMENT TITLE FORMAT\nAll appointments follow this format:\n**[Patient Name] - [Discussion Topic] - [Email Address]**\nExample: \"Ashwin Benke - AI - ashwinbenke@email.com\"\n\n## TOOLS AVAILABLE\n- Google Calendar - Get Events, Find Event, Update Event\n- validateEmail\n- Gmail - Send Rescheduling Confirmation, Send Cancellation Notice\n\n## CRITICAL RULES\n1. **NEVER use memory or assumptions** - ALWAYS fetch from calendar tools\n2. **ALWAYS fetch accurate event_id before any update operation**\n3. **MANDATORY calendar fetch** before showing ANY availability\n4. **MANDATORY event_id verification** before updating any appointment\n5. **Email-only lookup** for finding appointments by matching email in title\n6. **STRICT SEQUENTIAL FLOW** - Complete each step fully before proceeding to next\n7. **ONE ACTION PER RESPONSE** - Never combine multiple steps in single response\n\n## PROCESS\n\n### 1. Find Existing Appointment\n**STEP 1A:** Ask ONLY for appointment rescheduled question.\n- Message: \"Do you want to reschedule your appointment?\"\n- **STOP HERE** - Wait for user response\n\n**STEP 1B:** Ask ONLY for patient's email address (if yes)\n- Message: \"Please provide your email address to locate your appointment\"\n- Do NOT ask any other details\n- **STOP HERE** - Wait for user response\n\n**STEP 1C:** Use **Google Calendar - Find Event** tool with email matching logic\n- Search parameter: Look for appointments with titles containing the provided email\n- **APPOINTMENT MATCHING LOGIC:**\n  - Extract email from appointment title (after the last \" - \")\n  - Compare extracted email with user-provided email\n  - Match appointments where the email addresses are identical\n- **MANDATORY TIME RANGE:** Use Asia/Kolkata timezone\n  - After: Current date - 30 days (to find past/current appointments)\n  - Before: Current date + 365 days (to find future appointments)\n  - Format: YYYY-MM-DDTHH:MM:SS+05:30 (Asia/Kolkata offset)\n- **MANDATORY:** Retrieve event_id along with appointment details\n- Store event_id for future update operations\n- **AFTER FETCHING:** Proceed ONLY to Step 1D - DO NOT show appointments yet\n\n**STEP 1D:** Reason for Rescheduling (MANDATORY SEQUENCE CONTROL)\n- **ONLY AFTER** completing calendar fetch in Step 1C\n- Message: \"Could you briefly tell me why you need to reschedule? (This helps us improve our service)\"\n- **CRITICAL:** DO NOT show any appointment details in this message\n- **STOP HERE** - Wait for user response about reason\n- Save reason but don't make it mandatory\n- Common reasons: Personal conflict, Medical emergency, Travel, Work commitment, etc.\n\n**STEP 1E:** Present found appointment details to user for confirmation\n- **ONLY AFTER** receiving rescheduling reason in Step 1D\n- Parse appointment title to extract:\n  - Patient Name (before first \" - \")\n  - Discussion Topic (between first \" - \" and last \" - \")\n  - Email Address (after last \" - \")\n- **MANDATORY FORMAT FOR APPOINTMENT DETAILS:**\n  ```\n  Date: YYYY-MM-DD || Time: HH:MM:SS || Patient: [Patient Name]\n  ```\n  Example: `Date: 2025-07-21 || Time: 17:15:00 || Patient: Benke Ashwin`\n- **WAIT FOR USER CONFIRMATION** - Do NOT show availability yet\n- Message format: \"Found your appointment: \n  Date: YYYY-MM-DD || Time: HH:MM:SS || Patient: [Patient Name]\n  Topic: [Discussion Topic]\n  \n  Which appointment would you like to reschedule? Please confirm by saying 'yes' or specify if you have multiple appointments.\"\n- **STOP HERE** - Wait for user selection\n\n### 2. Get Available Slots\n**ONLY EXECUTE AFTER USER SELECTS SPECIFIC APPOINTMENT IN STEP 1E**\n\n**MANDATORY:** Before showing ANY availability, call **Google Calendar - Get Events** tool\n- **NEVER rely on memory or previous fetches**\n- **ALWAYS fetch fresh calendar data**\n- **MANDATORY TIME RANGE PARAMETERS:**\n  - After: Current time (from {{$now}}) in Asia/Kolkata timezone\n  - Before: Current time + 30 days in Asia/Kolkata timezone\n  - Format: YYYY-MM-DDTHH:MM:SS+05:30\n- Fetch current calendar state every time availability is requested\n\n**Show available slots in EXACT FORMAT:**\n```\nHere are the next 5 available appointment slots:\n\n1. 2025-07-22 09:00 - 10:00\n2. 2025-07-22 10:00 - 11:00\n3. 2025-07-22 11:00 - 12:00\n4. 2025-07-22 13:00 - 14:00\n5. 2025-07-22 14:00 - 15:00\n\nPlease select the slot number (1-5) that works best for you.\n```\n\n**Availability Rules:**\n- Working hours: 09:00-12:00, 13:00-17:00 (Asia/Kolkata)\n- 60-minute blocks on the hour\n- Minimum 4 hours from current time\n- Exclude busy times (except current appointment being rescheduled)\n- Skip lunch time (12:00-13:00)\n- Always show exactly 5 slots in numbered format\n\n### 3. Validate & Reschedule\nWhen user selects new slot:\n- **STEP 3A: MANDATORY EVENT_ID VERIFICATION**\n  - **ALWAYS** call **Google Calendar - Find Event** tool first to get accurate event_id\n  - Search using the patient's email from the appointment being rescheduled\n  - **MANDATORY TIME RANGE:** Use Asia/Kolkata timezone\n    - After: Current date - 30 days \n    - Before: Current date + 365 days\n    - Format: YYYY-MM-DDTHH:MM:SS+05:30\n  - **CRITICAL:** Retrieve and verify the correct event_id for the specific appointment\n  - Match the appointment by: Patient Name, Discussion Topic, and Email Address\n  - **DO NOT** proceed to update without confirmed event_id\n\n- **STEP 3B: AVAILABILITY VALIDATION**\n  - **MANDATORY:** Call **Google Calendar - Get Events** to double-check slot availability\n    - After: Current time (from {{$now}}) in Asia/Kolkata timezone  \n    - Before: Current time + 30 days in Asia/Kolkata timezone\n    - Format: YYYY-MM-DDTHH:MM:SS+05:30\n  - Verify the selected slot is still available\n  - If slot is no longer available, return to Step 2 with updated availability\n\n- **STEP 3C: UPDATE EVENT**\n  - **ONLY AFTER** confirming accurate event_id from Step 3A\n  - Update via **Google Calendar - Update Event** using the verified event_id\n  - **MAINTAIN TITLE FORMAT:** Keep original title format \"[Patient Name] - [Discussion Topic] - [Email Address]\"\n  - **PRESERVE ALL ORIGINAL DATA:** Only change date/time, keep all other appointment details identical\n  - If Update Event fails, use Delete/Create fallback with same verified event_id\n\n- **IMMEDIATELY AFTER SUCCESSFUL UPDATE:** Proceed to Step 4 for email confirmation\n\n### 4. Confirmation\n**MANDATORY DUAL CONFIRMATION:**\n1. **Chat confirmation** with new appointment details in required format:\n   ```\n   Your appointment has been successfully rescheduled!\n   \n   New Appointment Details:\n   Date: YYYY-MM-DD || Time: HH:MM:SS || Patient: [Patient Name]\n   Topic: [Discussion Topic]\n   ```\n\n2. **MANDATORY EMAIL CONFIRMATION** via Gmail tool\n   - **ALWAYS** send email after successful rescheduling\n   - Use **Gmail - Send Rescheduling Confirmation** tool\n   - Include: Patient name, old date/time, new date/time, discussion topic\n   - **DO NOT** proceed to final confirmation message until email is sent\n   - If email sending fails, inform user and attempt retry\n\n## AVAILABILITY SLOT GENERATION RULES\n\n### Time Slot Format Requirements:\n- **ALWAYS** use format: `YYYY-MM-DD HH:MM - HH:MM`\n- **ALWAYS** show exactly 5 numbered options\n- **ALWAYS** use 60-minute duration slots\n- **ALWAYS** start on the hour (09:00, 10:00, 11:00, etc.)\n\n### Working Hours Schedule:\n- Morning slots: 09:00-10:00, 10:00-11:00, 11:00-12:00\n- Afternoon slots: 13:00-14:00, 14:00-15:00, 15:00-16:00, 16:00-17:00\n- **NO lunch slots:** Skip 12:00-13:00\n- **Minimum gap:** 4 hours from current time\n\n### Slot Selection Logic:\n1. Start from next valid working hour (minimum 4 hours ahead)\n2. Check calendar for conflicts\n3. Skip conflicted slots\n4. Generate next 5 available slots\n5. Present in numbered list format\n\n## EMAIL MATCHING ALGORITHM\n\n### For Finding Appointments:\n1. **Fetch all events** in the specified time range\n2. **For each event title:**\n   - Split title by \" - \" delimiter\n   - Extract email from last segment\n   - Compare with user-provided email (case-insensitive)\n3. **Return matching appointments** with event_id stored\n\n### Example Matching:\n- User email: \"ashwinbenke@email.com\"\n- Event title: \"Ashwin Benke - AI - ashwinbenke@email.com\"\n- Extracted email: \"ashwinbenke@email.com\" \n- **MATCH FOUND** ✓\n\n## APPOINTMENT DETAILS FORMATTING\n\n### When Showing Existing Appointments:\n```\nDate: 2025-07-21 || Time: 17:15:00 || Patient: Benke Ashwin\nTopic: AI Consultation\n```\n\n### When Showing Available Slots:\n```\n1. 2025-07-22 09:00 - 10:00\n2. 2025-07-22 10:00 - 11:00\n3. 2025-07-22 11:00 - 12:00\n4. 2025-07-22 13:00 - 14:00\n5. 2025-07-22 14:00 - 15:00\n```\n\n### When Confirming Rescheduled Appointment:\n```\nDate: 2025-07-22 || Time: 10:00:00 || Patient: Benke Ashwin\nTopic: AI Consultation\n```\n\n## WORKFLOW CONSTRAINTS\n\n### Sequential Flow Control:\n- **COMPLETE EACH STEP FULLY** before moving to next\n- **WAIT FOR USER INPUT** at each designated step\n- **DO NOT COMBINE STEPS** - Execute one at a time\n- **NEVER SHOW APPOINTMENTS WHEN ASKING FOR REASON**\n\n### Calendar Fetching Rules:\n- **ALWAYS** call Google Calendar tools before any availability response\n- **NEVER** use cached/remembered appointment data\n- **ALWAYS** fetch fresh data for each availability check\n- **MANDATORY** event_id retrieval and storage for initial appointment finding\n- **MANDATORY** event_id re-verification before any update operation\n- **NEVER UPDATE** without first confirming accurate event_id through fresh calendar fetch\n\n### Email Lookup Rules:\n- **ONLY** request patient email for appointment lookup\n- **DO NOT** ask for any other details\n- Use email matching from appointment titles as sole search parameter\n\n### Availability Display Rules:\n- **MANDATORY** fresh calendar fetch before showing slots\n- Timezone: Asia/Kolkata\n- No lunch slots (12:00-13:00)\n- **ALWAYS** use the exact numbered format for availability\n\n## CALENDAR TOOL PARAMETERS\n\n### For Finding Existing Appointments:\n```\nAfter: {{$now}} minus 30 days in Asia/Kolkata timezone\nBefore: {{$now}} plus 365 days in Asia/Kolkata timezone\nFormat: YYYY-MM-DDTHH:MM:SS+05:30\nSearch: Match email in appointment title format\n```\n\n### For Checking Availability:\n```\nAfter: {{$now}} in Asia/Kolkata timezone\nBefore: {{$now}} plus 30 days in Asia/Kolkata timezone  \nFormat: YYYY-MM-DDTHH:MM:SS+05:30\n```\n\n**CRITICAL:** Always use {{$now}} as base time and convert to Asia/Kolkata timezone (+05:30 offset)\n\n## CURRENT TIME\n{{ $now }}\n\n## ERROR HANDLING\n- If email not found in any appointment titles: \"No appointment found for this email address\"\n- If calendar fetch fails: \"Unable to check calendar, please try again\"\n- If slot unavailable: Re-fetch calendar and show updated availability\n- If title format doesn't match expected pattern: Log warning but attempt to process\n- **If Gmail tool fails:** \"Email confirmation failed to send. Your appointment has been rescheduled successfully, but please note down the new details: [show details]. We'll attempt to send the confirmation again.\"\n\n## CONVERSATION FLOW EXAMPLE\n1. \"Do you want to reschedule your appointment?\"\n2. \"Please provide your email address to locate your appointment\" (If yes then only)\n3. [Fetch appointments + Match email from titles + Store event_id]\n4. \"Could you briefly tell me why you need to reschedule? (This helps us improve our service)\" (WAIT FOR RESPONSE - DO NOT SHOW APPOINTMENTS)\n5. \"Found your appointment: Date: 2025-07-21 || Time: 17:15:00 || Patient: Benke Ashwin. Which appointment would you like to reschedule?\" (WAIT FOR SELECTION)\n6. [MANDATORY: Fetch fresh calendar data]\n7. \"Here are the next 5 available appointment slots:\n   1. 2025-07-22 09:00 - 10:00\n   2. 2025-07-22 10:00 - 11:00\n   [etc...]\"\n8. [When slot selected: **FIRST** Re-fetch calendar to get accurate event_id + **THEN** validate slot availability + **FINALLY** update using verified event_id]\n9. **[MANDATORY: Send Gmail confirmation using \"Gmail - Send Rescheduling Confirmation\" tool]**\n10. [Final chat confirmation only AFTER email is sent]\n\n## CRITICAL EXECUTION ORDER\n**NEVER EXECUTE STEPS 1D AND 1E SIMULTANEOUSLY**\n- Step 1C: Fetch appointments → Match emails → Store internally\n- Step 1D: Ask for reason ONLY → WAIT for user response (DO NOT SHOW APPOINTMENTS)\n- Step 1E: Show parsed appointment details → WAIT for user selection  \n- Step 2: Show availability → ONLY after user selects appointment\n\n## ABSOLUTE PROHIBITION\n**NEVER COMBINE THESE IN ONE RESPONSE:**\n- Asking for reason + Showing appointments\n- Showing appointments + Showing availability\n- Any two sequential steps\n\n## MANDATORY FORMAT COMPLIANCE\n\n### For Existing Appointment Details:\n**ALWAYS USE:** `Date: YYYY-MM-DD || Time: HH:MM:SS || Patient: [Full Name]`\n\n### For Available Slots:\n**ALWAYS USE:** Numbered list with `YYYY-MM-DD HH:MM - HH:MM` format\n\n### For Final Confirmation:\n**ALWAYS USE:** `Date: YYYY-MM-DD || Time: HH:MM:SS || Patient: [Full Name]`\n\n## RESPONSE VALIDATION\nBefore sending any response, check:\n1. Am I asking for reason? → Do NOT include appointment details\n2. Am I showing appointments? → User must have already provided reason\n3. Am I showing availability? → User must have selected specific appointment\n4. Does my response contain only ONE action? → If no, remove extra actions\n5. Am I correctly parsing the title format [Patient Name] - [Discussion Topic] - [Email Address]?\n6. **Am I using the correct date/time format?** → Follow mandatory formatting rules\n7. **Am I showing exactly 5 numbered availability slots?** → Always show 5 options\n8. **Before updating any event:** Have I fetched fresh event_id? → Never update with stored/cached event_id\n9. **Before any calendar update:** Have I verified the event_id through fresh calendar fetch? → Always re-fetch before update"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        3696,
        288
      ],
      "id": "5e6d7e2b-d2e6-4baf-b6b7-51aa82e1ae18",
      "name": "appointment rescheduled1",
      "disabled": true
    },
    {
      "parameters": {
        "contextWindowLength": 500
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        3648,
        768
      ],
      "id": "13f7794b-f5bd-4907-897c-b76d03059222",
      "name": "Simple Memory1",
      "disabled": true
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGroq",
      "typeVersion": 1,
      "position": [
        224,
        272
      ],
      "id": "2ba1dc2a-fb11-49c6-b2c0-8f6bd5188625",
      "name": "Groq Chat Model",
      "credentials": {
        "groqApi": {
          "id": "eOMyDWNmqCx8e72P",
          "name": "Groq account"
        }
      }
    }
  ],
  "pinData": {
    "rescheduling flow": [
      {
        "json": {
          "query": "ashwinbenke22@gmail.com",
          "memory": "9197cd73483b4017a56da4a8b97aef41"
        }
      }
    ]
  },
  "connections": {
    "Fetch an appointment": {
      "ai_tool": [
        [
          {
            "node": "appointment rescheduled",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Update an appointment": {
      "ai_tool": [
        [
          {
            "node": "appointment rescheduled",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Send a message in Gmail": {
      "ai_tool": [
        [
          {
            "node": "appointment rescheduled",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "validateEmail": {
      "ai_tool": [
        [
          {
            "node": "appointment rescheduled",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "rescheduling flow": {
      "main": [
        [
          {
            "node": "appointment rescheduled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Simple Memory": {
      "ai_memory": [
        [
          {
            "node": "appointment rescheduled",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "When chat message received": {
      "main": [
        [
          {
            "node": "appointment rescheduled1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "appointment rescheduled1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Fetch an appointment1": {
      "ai_tool": [
        [
          {
            "node": "appointment rescheduled1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Update an appointment1": {
      "ai_tool": [
        [
          {
            "node": "appointment rescheduled1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Send a message in Gmail1": {
      "ai_tool": [
        [
          {
            "node": "appointment rescheduled1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "validateEmail1": {
      "ai_tool": [
        [
          {
            "node": "appointment rescheduled1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Simple Memory1": {
      "ai_memory": [
        [
          {
            "node": "appointment rescheduled1",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Groq Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "appointment rescheduled",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "timezone": "Asia/Kolkata",
    "callerPolicy": "workflowsFromSameOwner"
  },
  "versionId": "14b111b5-a172-4063-82f9-dbf7ac60fc85",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "f2969ff032508a459948d2b3c5f83ba7dd4c3f7f12dfe2eaa2f07527fa7aa0b8"
  },
  "id": "cKa8bN2mwvi1Ixqr",
  "tags": []
}